-- vim: syntax=moon
fs = require 'fs'
moonscript = require 'moonscript'
package.path = "#{package.path};lib/?.lua;lib/?/init.lua"
package.moonpath = moonscript.create_moonpath(package.path)
insert: append = table
load_spookfile = _G.load_spookfile
log = require 'systemd-journal'
_G.log = log
:after = require 'moonbar_util'

-- How much log output can you handle? (ERR, WARN, INFO, DEBUG)
log_level "INFO"

-- We don't want buffered io on stdout here
io.stdout\setvbuf 'no'

Types = require("syscall").t
:execute, :command = require 'command'

json = require "json"
normal_color = "#FFFFFF"
warning_color = "#FFFC00"
critical_color = "#FF0000"
good_color = "#4CBB17"

-- begin infinite i3 json stream
-- wrap it in a guard so that on spook
-- hot reload we don't output this again
unless _G.INIT
  io.stdout\write '{"version":1,"click_events":true}', "\n"
  io.stdout\write "[[]", "\n"
  _G.INIT = true

:block, :blocklist, :named_blocks, :clear_blocklist = require 'block'

write_blocks = ->
  data = [block\to_table! for block in *blocklist]
  io.stdout\write ",#{json.encode(data)}", "\n"

-- 25 x 4 - 3 5 min breaks, 4th break is 15 min
pomodoro = {
  {25, true}
  {5, false}
  {25, true}
  {5, false}
  {25, true}
  {5, false}
  {25, true}
  {15, false}
}
pomodoro_time = 0
pomodoro_current = 1
pomodoro_paused = true

break_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/hold.svg"
break_over_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/like.svg"
block 'Pomodoro', ->
  interval 60.0
  label " "
  text "Pomodoro: paused"
  on_update =>
    return if pomodoro_paused
    pomodoro_time += 1
    curr = pomodoro[pomodoro_current]
    time, work = curr[1], curr[2]
    if work
      label " "
      text "Pomodoro: work"
    else
      label " "
      text "Pomodoro: break (#{time} min)"
    if pomodoro_time >= time
      pomodoro_current += 1
      pomodoro_time = 0
      if pomodoro_current >= #pomodoro
        pomodoro_current = 1
      curr = pomodoro[pomodoro_current]
      new_time, new_work = curr[1], curr[2]
      if work
        os.execute "/usr/bin/notify-send -i #{break_icon} -u critical 'Break' 'Time for a #{new_time} min break!'"
      else
        os.execute "/usr/bin/notify-send -i #{break_over_icon} 'Break over' 'The break is over'"
        pomodoro_paused = true
        text "Pomodoro: paused"
        label " "
  on_left_click =>
    return unless pomodoro_paused
    color warning_color
    pomodoro_paused = false
    text "Pomodoro: start"
    after 1.0, (t) ->
      curr = pomodoro[pomodoro_current]
      time, work = curr[1], curr[2]
      if work
        label " "
        text "Pomodoro: work"
      else
        -- we shouldn't ever get here as it is
        label " "
        text "Pomodoro: break"
      color normal_color

backup_complete_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/cloud-computing-2.svg"
backup_fail_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/cloud-computing-5.svg"
rbsnap = "#{os.getenv('HOME')}/Local/bin/rbsnap"
backup = "/home"
remote = os.getenv('RBSNAP_REMOTE')
port = os.getenv('RBSNAP_PORT')
do_backup = false
if fs.is_present(rbsnap) and remote
  block 'Backup', ->
    text "Backup"
    color normal_color
    interval 30.0 * 60 -- 30 minutes

    on_update =>
      label ''
      color normal_color
      text "Backup"
      if do_backup
        color good_color
        text "Backing up /home..."
        start = os.time!
        stamp = os.date '%H:%M'
        out, err, status = execute "/usr/bin/sudo #{rbsnap} #{backup} #{remote} #{port}", on_read: log.info, on_err: log.error
        log.debug "rbsnap status: #{status}"
        success = status == 0
        finish = os.time!
        elapsed = finish - start
        time_taken = if elapsed == 1
          "#{elapsed} second"
        else
          "#{elapsed} seconds"

        after 5.0, (t) ->
          color normal_color
          if success
            text "Backup (last: #{stamp})"
          else
            color critical_color
            text "Backup (failed at: #{stamp})"

        if success
          os.execute "/usr/bin/notify-send -i #{backup_complete_icon} 'Backup' 'Backup of #{backup} to #{remote} finished in #{time_taken}.'"
          text "Backup succeeded"
          color good_color
        else
          os.execute "/usr/bin/notify-send -i #{backup_fail_icon} -u critical 'Backup' 'Backup of #{backup} to #{remote} failed in #{time_taken}!'"
          text "Backup failed"
          color critical_color

      do_backup = true

    on_left_click => @update!

net_throughput = require "net_throughput"
block 'Bandwidth', ->
  net_if = net_throughput!
  interval 1.0
  on_update =>
    status, err = net_if!
    return unless status

    unless net_if.up
      color critical_color
      text " net down"
      return

    if net_if.interface\match '^wlp'
      label " "
    else
      label " "

    color normal_color
    text " #{net_if.receive_rate}#{net_if.rx_unit}  #{net_if.transmit_rate}#{net_if.tx_unit}"

block 'Date', ->
  interval 1.0
  label " "
  color normal_color
  on_update =>
    text os.date("%b-%d %H:%M:%S")
  on_left_click =>
    os.execute "gsimplecal &"

block 'External IP', ->
  ip = 'Unknown'
  color normal_color
  label " "
  interval 30.0

  on_update =>
    output = command "/usr/bin/dig TXT +short o-o.myaddr.l.google.com @ns1.google.com"
    log.debug "dig: #{output}"
    return unless success
    ip = (output\gsub('"',''))\trim!
    text (ip != '' and ip or 'Unknown')

  on_left_click =>
    color warning_color
    text "<copied>"
    os.execute "echo '#{ip}' | xclip -selection clipboard"
    after 1.0, (t) ->
      color normal_color
      text ip

cpu_usage = require "cpu_usage"
block 'Cpu Usage', ->
  cpu = cpu_usage!
  text "0%"
  label " "
  interval 2.0
  on_update =>
    cpu = cpu_usage!
    if cpu < 50
      color normal_color
    else if cpu < 70
      color warning_color
    else
      color critical_color
    text "#{cpu}%"

if fs.is_present '/usr/bin/acpi'
  battery_acpi = require 'battery_acpi'
  block 'Battery', ->
    local time_remaining, alert_sent
    percent = 100
    status = 'charging'
    batt100   = ' '
    batt75    = ' '
    batt50    = ' '
    batt25    = ' '
    batt0     = ' '
    charging  = ' '
    interval 15.0
    on_update =>
      output = command '/usr/bin/acpi -b'
      log.debug "acpi: #{output}"
      return unless success

      status, percent, time_remaining = battery_acpi output
      return unless status

      color normal_color
      tr = time_remaining and " (#{time_remaining})" or ''
      text "#{percent}% #{tr}"

      if status == 'discharging'
        if percent < 10
          unless alert_sent
            alert_sent = true
            os.execute "/usr/bin/notify-send 'Low Battery' 'There is only #{time_remaining} of use left'"
          color critical_color
          label batt0
        else if percent < 25
          color warning_color
          label batt25
        else if percent < 50
          color warning_color
          label tt25
        else if percent < 75
          label batt75
        else
          label batt100
      else if status == 'charging'
        alert_sent = false
        color good_color
        label charging

if fs.is_present '/usr/bin/xrandr'
  block "Monitor", ->
    interval 30.0
    label ' '
    symbol = ""

    on_update =>
      output = command '/usr/bin/xrandr -q'
      log.debug "xrandr: #{output}"
      return unless output

      for line in *output\split("\n")
        if line\match '^DP1'
          if line\match '%d+mm'
            text symbol
            return
      text 'OFF'

if fs.is_present '/usr/bin/pacman'
  updates = 0
  update_block = block 'Updates', ->
    color normal_color
    interval 30.0 * 60 -- 30 minutes

    on_update =>
      color good_color
      label ''
      text "Checking for updates..."
      stdout, stderr, status = execute '/usr/bin/pacman -Qu', on_read: log.info, on_err: log.error
      updates = if status > 0
        0
      else
        lines = #(stdout\trim!\split("\n"))
        tonumber(lines) or 0

      if updates > 0
        label ' '
        color warning_color
        text "#{updates} updates available"
      else
        label ' '
        color normal_color
        text "No updates available"

    on_left_click =>
      if updates > 0
        stdout, stderr, status = execute "/usr/bin/gnome-terminal -e 'sudo pacman -Syu'"
        @update!
      else
        @update!

if fs.is_present '/usr/lib/update-notifier/apt-check'
  updates = 0
  update_block = block 'Updates', ->
    color normal_color
    interval 30.0 * 60 -- 30 minutes

    on_update =>
      color good_color
      label ''
      text "Checking for updates..."
      output = command '/usr/lib/update-notifier/apt-check --human-readable'
      log.debug "apt-check: #{output}"
      return unless success

      updates = output\match("^%d+")
      updates = updates and tonumber(updates) or 0

      if updates > 0
        label ' '
        color warning_color
        text "#{updates} updates available"
      else
        label ' '
        color normal_color
        text "No updates available"

    on_left_click =>
      if updates > 0
        command '/usr/bin/update-manager'
        @update!
      else
        @update!

Pulse = require "pulse"
round = math.round
sinklist = Pulse\list_sinks!
pulse_blocks = {}
update_pulse_blocks = -> block\update! for block in *pulse_blocks

sinkupdater = timer 5.0, (t) ->
  current_sink_list = Pulse\list_sinks!
  if #current_sink_list != #sinklist
    clear_blocklist!
    load_spookfile!
  t\again!

for sink in *sinklist
  name = if sink.name\match '^bluez'
    'BT'
  else
    n = sink.name\split('.')
    name = n[#n]
    name = name\split('-')
    name[1]\upper!
  b = block "Volume #{name}", ->
    pulse = Pulse.new sink
    step = 0.02
    interval 5.0
    label "♪ #{name} "
    text '?'

    on_update =>

      muted = pulse.mute
      current = pulse.is_current
      if muted
        text "mute"
      else
        text "#{round(pulse.volume * 100)}%"

      if current and muted
        color warning_color
      else if current
        color good_color
      else
        color normal_color

    on_left_click =>
      if pulse.is_current
        pulse\toggle_mute!
        @update!
      else
        pulse\make_current!
        update_pulse_blocks! -- all volume blocks including self
      write_blocks! -- for the best possible feedback

    on_scroll_up =>
      pulse.volume = pulse.volume + step
      @update!
      write_blocks! -- for the best possible feedback

    on_scroll_down =>
      pulse.volume = pulse.volume - step
      @update!
      write_blocks! -- for the best possible feedback

  append pulse_blocks, b

-- Let's reload this file when changing it, therefore
-- spook itself can be reconfigured without restarting it.
watch_file 'Spookfile', ->
  on_changed (event) ->
    clear_blocklist!
    load_spookfile!

i3conf = "#{os.getenv('HOME')}/.i3"
genconf = "#{i3conf}/genconf"
restart_i3 = "/usr/local/bin/restart-i3"

watch "#{os.getenv('HOME')}/.i3", ->
  on_changed '(.*config%..*)', (event, name) ->
    os.execute genconf
    os.execute restart_i3

write_blocks!

json_writer = timer 0.5, (t) ->
  write_blocks!
  t\again!

stdin = Types.fd(0) -- MUST be wrapped in a metatype
stdin_reader = on_read stdin, (r, fd) ->
  data = fd\read!
  if data
    line, replaced = data\gsub '^%[', ''
    line, replaced = line\gsub '^,', ''
    status, event = pcall json.decode, line
    if status
      return unless event.name
      block = named_blocks[event.name]
      return unless block
      switch event.button
        when 1
          block.left_click event
          write_blocks!
        when 2
          block.middle_click event
          write_blocks!
        when 3
          block.right_click event
          write_blocks!
        when 4
          block.scroll_up event
          write_blocks!
        when 5
          block.scroll_down event
          write_blocks!

-- Just throwing in this call to better catch
-- issues stemming from GC
collectgarbage!
