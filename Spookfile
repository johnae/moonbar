-- vim: syntax=moon
fs = require 'fs'
moonscript = require 'moonscript'
package.path = "#{package.path};lib/?.lua;lib/?/init.lua"
package.moonpath = moonscript.create_moonpath(package.path)
insert: append = table
load_spookfile = _G.load_spookfile
log = require 'systemd-journal'
_G.log = log
gettimeofday = gettimeofday
round = math.round
S = require "syscall"
:execute, :spawn = require 'process'
:after = require 'moonbar_util'
:format = string
:concat, insert: append = table
command = require 'command'

on_sway_wm = os.getenv('DESKTOP_SESSION')\match '^sway'

cache_dir = "#{os.getenv('HOME')}/.cache/moonbar"
fs.mkdir_p cache_dir
cache_write = (data, name) ->
  path = "#{cache_dir}/#{name}"
  f = io.open path, "w"
  if f
    f\write data
    f\close!
    return true
  false

cache_read = (name) ->
  path = "#{cache_dir}/#{name}"
  f = io.open path, "r"
  if f
    content = f\read!
    f\close!
    return content, true
  nil, false

-- How much log output can you handle? (ERR, WARN, INFO, DEBUG)
log_level "INFO"

log.info "loading moonbar..."

-- We don't want buffered io on stdout here
io.stdout\setvbuf 'no'

json = require "json"
normal_color = "#FFFFFF"
warning_color = "#fbdc1b"
critical_color = "#d24939"
good_color = "#78b037"

-- begin infinite i3 json stream
-- wrap it in a guard so that on spook
-- hot reload we don't output this again
unless _G.INIT
  io.stdout\write '{"version":1,"click_events":true}', "\n"
  io.stdout\write "[[]", "\n"
  _G.INIT = true

:block, :blocklist, :named_blocks, :clear_blocklist = require 'block'

write_blocks = ->
  data = [block\to_table! for block in *blocklist]
  io.stdout\write ",#{json.encode(data)}", "\n"

-- 25 x 4 - 3 5 min breaks, 4th break is 15 min
pomodoro = {
  {25, true}
  {5, false}
  {25, true}
  {5, false}
  {25, true}
  {5, false}
  {25, true}
  {15, false}
}
pomodoro_time = 0
pomodoro_current = 1
pomodoro_paused = true

break_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/hold.svg"
break_over_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/like.svg"
block 'Pomodoro', ->
  interval 60.0
  label " "
  text "Pomodoro: paused"
  on_update =>
    return if pomodoro_paused
    color normal_color
    pomodoro_time += 1
    curr = pomodoro[pomodoro_current]
    time, work = curr[1], curr[2]
    if work
      label " "
      text "Pomodoro: work"
    else
      color good_color
      label " "
      text "Pomodoro: break (#{time} min)"
    if pomodoro_time >= time
      pomodoro_current += 1
      pomodoro_time = 0
      if pomodoro_current >= #pomodoro
        pomodoro_current = 1
      curr = pomodoro[pomodoro_current]
      new_time, new_work = curr[1], curr[2]
      if work
        execute "/usr/bin/notify-send -i #{break_icon} -u critical 'Break' 'Time for a #{new_time} min break!'"
      else
        execute "/usr/bin/notify-send -i #{break_over_icon} 'Break over' 'The break is over'"
        pomodoro_paused = true
        text "Pomodoro: paused"
        label " "
  on_left_click =>
    return unless pomodoro_paused
    color warning_color
    pomodoro_paused = false
    text "Pomodoro: start"
    after 1.0, (t) ->
      curr = pomodoro[pomodoro_current]
      time, work = curr[1], curr[2]
      if work
        label " "
        text "Pomodoro: work"
      else
        -- we shouldn't ever get here as it is
        label " "
        text "Pomodoro: break"
      color normal_color

if api_key = os.getenv('SYNCTHING_API_KEY')

  curl = "curl -H 'X-API-Key: #{api_key}' -s 'http://localhost:8384/rest/"
  list_folders = curl .. "system/config' | jq -r '[.folders[] | {id: .id, path: .path}]'"
  state_for = (folder) ->
    folder = folder.id\gsub '%s', '%%20'
    curl .. "db/status?folder=#{folder}' | jq -r '.state'"

  block 'Syncthing', ->
    label 'Sync: '
    color normal_color
    interval 5

    on_update =>
      folders = json.decode(command list_folders)
      for folder in *folders
        out = command state_for(folder)
        return unless out
        state = out\trim!
        if state != 'idle'
          color warning_color
          text state
          return
      color normal_color
      text 'idle'

    on_left_click => @update!

backup_complete_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/cloud-computing-2.svg"
backup_fail_icon = "#{os.getenv('HOME')}/Pictures/icons/essential/cloud-computing-5.svg"
remote = os.getenv('RBSNAP_REMOTE')
port = os.getenv('RBSNAP_PORT')

rbsnap_backup = require('rbsnap')(log)
backup_every = 60*30 -- 30 minutes
backup_path = "/home"
home_backup = rbsnap_backup(remote, port, backup_path, backup_every)
forced_backup = false
grace_time = 10
just_started = true
failed = 0

if home_backup.can_backup!
  block 'Backup', ->
    label " Backup: "
    color warning_color
    interval 1 -- update every second
    update_status = ->
      just_started = false
      last = home_backup.human_time_of_last_backup!
      nxt = home_backup.human_time_until_next_backup!
      if home_backup.last_status!
        if backup_every - home_backup.time_since_last_backup! < 90
          color warning_color
        else
          color normal_color
      else
        color critical_color
      text "last #{last}, next #{nxt}"

    on_update =>
      grace_time -= 1 if grace_time > 0
      grace_time = 0 if grace_time < 0
      if just_started
        text "grace time #{grace_time}s"
      return if grace_time > 0
      return if home_backup.backing_up!
      update_status!

      if home_backup.backup_is_due! or forced_backup
        forced_backup = false
        color good_color
        text "/home..."
        start = gettimeofday!
        success = home_backup.backup_now!
        finish = gettimeofday!
        elapsed = round((finish - start) / 1000.0, 2)
        time_taken = "#{elapsed} seconds"
        grace_time = 20
        if success
          failed = 0
          color good_color
          text "succeeded"
          execute "/usr/bin/notify-send -i #{backup_complete_icon} 'Backup' 'Backup of #{backup_path} to #{remote} finished in #{time_taken}.'"
        else
          failed += 1
          grace_time *= failed
          text "failed"
          color critical_color
          execute "/usr/bin/notify-send -i #{backup_fail_icon} -u critical 'Backup' 'Backup of #{backup_path} to #{remote} failed in #{time_taken}!'"

    on_left_click =>
      forced_backup = true
      @update!

net_throughput = require "net_throughput"
block 'Bandwidth', ->
  net_if = net_throughput!
  interval 1.0
  on_update =>
    status, err = net_if!
    return unless status

    unless net_if.up
      color critical_color
      text " net down"
      return

    if net_if.interface\match '^wlp'
      label " "
    else
      label " "

    color normal_color
    text " #{net_if.receive_rate}#{net_if.rx_unit}  #{net_if.transmit_rate}#{net_if.tx_unit}"

block 'Date', ->
  interval 1.0
  label " "
  color normal_color
  on_update =>
    text os.date("%b-%d %H:%M:%S")
  on_left_click =>
    execute "gsimplecal"

block 'External IP', ->
  ip = 'Unknown'
  color normal_color
  label " "
  interval 30.0

  on_update =>
    out = command "/usr/bin/dig TXT +short o-o.myaddr.l.google.com @ns1.google.com"
    return unless out
    ip = (out\gsub('"',''))\trim!
    text (ip != '' and ip or 'Unknown')

  on_left_click =>
    color warning_color
    text "<copied>"
    execute "echo '#{ip}' | xclip -selection clipboard"
    after 1.0, (t) ->
      color normal_color
      text ip

cpu_usage = require "cpu_usage"
block 'Cpu Usage', ->
  cpu = cpu_usage!
  text "#{format('%5.1f', 0)}%"
  label " "
  interval 2.0
  on_update =>
    cpu = cpu_usage!
    if cpu < 50
      color normal_color
    else if cpu < 70
      color warning_color
    else
      color critical_color
    text "#{format('%5.1f', cpu)}%"

if fs.is_present '/usr/bin/acpi'
  battery_acpi = require 'battery_acpi'
  block 'Battery', ->
    local time_remaining, alert_sent
    percent = 100
    status = 'charging'
    batt100   = ' '
    batt75    = ' '
    batt50    = ' '
    batt25    = ' '
    batt0     = ' '
    charging  = ' '
    interval 30.0
    on_update =>
      out = command '/usr/bin/acpi -b'
      state, percent, time_remaining = battery_acpi out
      return unless state

      color normal_color
      tr = time_remaining and " (#{time_remaining})" or ''
      text "#{format('%3d', percent)}% #{tr}"

      if state == 'discharging'
        if percent < 10
          unless alert_sent
            alert_sent = true
            execute "/usr/bin/notify-send 'Low Battery' 'There is only #{time_remaining} of use left'"
          color critical_color
          label batt0
        else if percent < 25
          color warning_color
          label batt25
        else if percent < 50
          color warning_color
          label tt25
        else if percent < 75
          label batt75
        else
          label batt100
      else if state == 'charging' or state == 'full'
        alert_sent = false
        color good_color
        label charging

if fs.is_present '/usr/bin/pacman'
  updates = 0
  update_block = block 'Updates', ->
    color normal_color
    interval 30.0 * 60 -- 30 minutes

    on_update =>
      color good_color
      label ''
      text "Looking for updates..."
      updates = if out = command '/usr/bin/pacman -Qu'
        lines = #(out\trim!\split("\n"))
        tonumber(lines) or 0
      else
        0

      after 1.0, (t) ->
        if updates > 0
          label ' '
          color warning_color
          text "#{updates} pkgs out-of-date"
        else
          label ' '
          color normal_color
          text "System up-to-date"

    on_left_click =>
      if updates > 0
        color warning_color
        text "Updating pkgs..."
        spawn "/home/john/Local/bin/alacritty -e sudo pacman -Syu", on_read: log.info, on_err: log.error
        @update!
      else
        @update!
      write_blocks!

if fs.is_present '/usr/lib/update-notifier/apt-check'
  updates = 0
  update_block = block 'Updates', ->
    color normal_color
    interval 30.0 * 60 -- 30 minutes

    on_update =>
      color good_color
      label ''
      text "Checking for updates..."
      out = command '/usr/lib/update-notifier/apt-check --human-readable'
      updates = out\match("^%d+")
      updates = updates and tonumber(updates) or 0

      if updates > 0
        label ' '
        color warning_color
        text "#{updates} updates available"
      else
        label ' '
        color normal_color
        text "No updates available"

    on_left_click =>
      if updates > 0
        spawn '/usr/bin/update-manager', on_read: log.info, on_err: log.error
        @update!
      else
        @update!
      write_blocks!

Pulse = require "pulse"
round = math.round
sinklist = Pulse\list_sinks!
pulse_blocks = {}
update_pulse_blocks = -> block\update! for block in *pulse_blocks

sinkupdater = timer 5.0, (t) ->
  current_sink_list = Pulse\list_sinks!
  if #current_sink_list != #sinklist
    clear_blocklist!
    load_spookfile!
  t\again!

for sink in *sinklist
  name = if sink.name\match '^bluez'
    'BT'
  else
    n = sink.name\split('.')
    name = n[#n]
    name = name\split('-')
    name[1]\upper!
  b = block "Volume #{name}", ->
    pulse = Pulse.new sink
    step = 0.02
    interval 5.0
    label "♪ #{name} "
    text '?'

    on_update =>

      muted = pulse.mute
      current = pulse.is_current
      if muted
        text "mute"
      else
        text "#{format('%3d', round(pulse.volume * 100))}%"

      if current and muted
        color warning_color
      else if current
        color good_color
      else
        log.info "normal because current: #{current}, muted: #{muted}"
        color normal_color

    on_left_click =>
      if pulse.is_current
        pulse\toggle_mute!
        @update!
      else
        pulse\make_current!
        update_pulse_blocks! -- all volume blocks including self
      write_blocks! -- for the best possible feedback

    on_scroll_up =>
      pulse.volume = pulse.volume + step
      @update!
      write_blocks! -- for the best possible feedback

    on_scroll_down =>
      pulse.volume = pulse.volume - step
      @update!
      write_blocks! -- for the best possible feedback

  append pulse_blocks, b

-- Let's reload this file when changing it, therefore
-- spook itself can be reconfigured without restarting it.
watch_file 'Spookfile', ->
  on_changed (event) ->
    clear_blocklist!
    load_spookfile!

if on_sway_wm
  swayconf = "#{os.getenv('HOME')}/.config/sway"

  watch swayconf, ->
    on_changed 'config', (event, name) ->
      log.info "Reload swayconf"
      execute "swaymsg reload"

  watch "#{os.getenv('HOME')}/Pictures", ->
    on_changed '.*%.jpg', (event) ->
      log.info "Change wallpaper"
      execute "swaymsg output * #{os.getenv('HOME')}/Pictures/wallpaper.jpg fill"
else
  i3conf = "#{os.getenv('HOME')}/.i3"
  genconf = "#{i3conf}/genconf"
  restart_i3 = "/usr/local/bin/restart-i3"
  restart_compton = "killall compton && #{i3conf}/compton"

  watch i3conf, ->
    on_changed '(.*config%..*)', (event, name) ->
      execute genconf
      execute restart_i3
    on_changed '(.*compton%.conf)', (event, name) ->
      execute restart_compton

  watch "#{os.getenv('HOME')}/Pictures", ->
    on_changed '.*%.jpg', (event) ->
      log.info "Change wallpaper"
      execute "feh --bg-fill #{os.getenv('HOME')}/Pictures/wallpaper.jpg"

write_blocks!

json_writer = every 0.5, (t) -> write_blocks!

stdin_reader = on_read S.stdin, (r, fd) ->
  data = fd\read!
  if data
    line, replaced = data\gsub '^%[', ''
    line, replaced = line\gsub '^,', ''
    status, event = pcall json.decode, line
    if status
      return unless event.name
      block = named_blocks[event.name]
      return unless block
      switch event.button
        when 1
          block.left_click event
          write_blocks!
        when 2
          block.middle_click event
          write_blocks!
        when 3
          block.right_click event
          write_blocks!
        when 4
          block.scroll_up event
          write_blocks!
        when 5
          block.scroll_down event
          write_blocks!

-- Just throwing in this call to better catch
-- issues stemming from GC
collectgarbage!
